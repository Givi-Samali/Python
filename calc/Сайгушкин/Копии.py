# Сначала на более быстром ксероксе (пусть x) делаем копию, потом шлепаем на быстром M копий, на медленном N-1-M.
# Очевидно, что полное время
N, x, y = map(int, input().split())
if x > y:
    x, y = y, x
# Понятно, что минимум будет, когда времена примерно равны, т.е.
M = y * (N - 1) // (x + y)
T = x + max(x * M, y * (N - 1 - M))
# Вот и проверим пару значений в поисках минимума - на 1 меньше и на 1 больше, сильнее вряд ли будут отличаться...
for m in range(max(0, M - 1), min(N - 1, M) + 2):
    t = x + max(x * m, y * (N - 1 - m))
    if t < T:
        T = t
print(T)

# Определение более быстрого ксерокса:

# Мы сравниваем скорости копирования двух ксероксов (x и y) и выбираем тот, который копирует быстрее, помещаем его
# время копирования в переменную x. Мы делаем это, чтобы использовать его как базовое время копирования. Расчет
# количества копий на медленном ксероксе (M):

# Мы рассчитываем, сколько копий следует сделать на более медленном ксероксе, чтобы общее время копирования было
# минимальным. Мы делаем это, учитывая, что на более медленном ксероксе мы должны сделать (N - 1) копий (поскольку
# первую мы уже сделаем на быстром ксероксе), и делим это на сумму скоростей копирования обоих ксероксов. Вычисление
# общего времени (T):

# Мы сначала учитываем время, необходимое для создания первой копии на быстром ксероксе.
# Затем мы выбираем максимальное время из двух вариантов:
# Вариант 1: Все остальные копии делаются на быстром ксероксе (x * M).
# Вариант 2: Все остальные копии делаются на медленном ксероксе (y * (N - 1 - M)).
# Поиск более оптимального решения:

# Мы ищем, есть ли возможность сделать на одну копию больше или меньше на медленном ксероксе, чтобы сократить общее
# время копирования. Для этого мы перебираем значения M - 1, M, и M + 1, проверяя общее время для каждого из них.
# Если мы находим более быстрое время, мы обновляем общее время. Вывод результатов:

# Мы выводим общее минимальное время, которое потребуется для создания всех копий.
